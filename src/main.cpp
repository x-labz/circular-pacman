
#include "Pokitto.h" // include Pokitto library

#include "Synth.h"
#include "pacman.h"
#include "pacman_text_bitmaps.h"
#include "fixmath.h"
#include "buttons.h"

#define OFFSET_X (220-128)/2
#define OFFSET_Y (176-128)/2

const uint16_t pacman_palette[] =
{
    0,
    0b0000000000011111,
    0b0000011111100000,
    0b1111100000000000,
    0xffff,
    0b0111100000000000,
    0b0000001111100000,
    0b0000000000001111,
    0xFFE0,
    0xFDDF,
    0x07FF,
    0xFDCA,
    0,
    0,
    0,
    0
};

void draw_text(uint8_t x0, uint8_t y0, const bitmap_type* bitmap) ;
void drawline(int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint8_t color);
void arc(uint16_t x0, uint16_t y0, uint16_t r, fix16_t start, fix16_t end, uint8_t color, coord * result_start, coord *result_end);
void filled_arc(uint16_t x0, uint16_t y0, uint16_t r, fix16_t start, fix16_t end,  uint8_t color);
void ghost(uint16_t x0, uint16_t y0, fix16_t angle, uint8_t color);
void circle(uint16_t x0, uint16_t y0, uint16_t r,uint8_t color);
void draw_pacman( state_type* s);
void calc_state(state_type* state, button_type* buttons);
bool checkGapGhost(state_type* state, int8_t index, int16_t dir);
bool checkGap(state_type* state, int16_t dir) ;
void state_init(state_type* state);
void get_buttons( button_type * state );

Pokitto::Core mygame; //create Pokitto application instance
Pokitto::Sound snd;
//sfxcookie sfx;

int main ()
{
    const bitmap_type* image_p;

    //sfx.begin("BSFXedit",sfx);
    //sfx.init() ;
    mygame.begin(); // start the application
    mygame.display.load565Palette(pacman_palette) ;
    mygame.display.setColor(1,0); // set foreground and background colors from palette
    //mygame.display.setFont(fontMonkey); // choose a lovely font
    mygame.display.setInvisibleColor(0);
    /* the "while" loop runs as long as the program is running */
    state_type state;
    state_init(&state);

    snd.ampEnable(1);

    while (mygame.isRunning())
    {
        /* mygame.update() is processed whenever it is time to update the screen */

        if (mygame.update())
        {
            draw_pacman( &state);

            get_buttons(&buttons_state);

            switch (state.game_state)
            {
            case GAME_GET_READY:
                image_p = &(pacman_texts_array[0]);
                if (!buttons_state.button_up && buttons_state.button_up_1)
                {
                    state.game_state = GAME_RUN;
                    image_p = NULL;
                    // setOSC(&osc1,1,3,0,0,1,46,246,160,39,1,59,0,0,13,0,0) ;
                }
                break;
            case GAME_RUN:
                calc_state(&state, &buttons_state);
                break;
            case GAME_GAME_OVER:
                image_p = &pacman_texts_array[1];
                if (!buttons_state.button_up && buttons_state.button_up_1)
                {
                    state_init(&state);
                }
                if (!buttons_state.button_down && buttons_state.button_down_1)
                {
                    //return false;
                }
                break;
            case GAME_YOU_WIN:
                image_p = &pacman_texts_array[2];
                if (!buttons_state.button_up && buttons_state.button_up_1)
                {
                    if (!buttons_state.button_up && buttons_state.button_up_1)
                    {
                        state_init(&state);
                    }
                    if (!buttons_state.button_down && buttons_state.button_down_1)
                    {
                        return false;
                    }
                }
                break;
            }

            if (image_p != NULL && state.text_visible > 8)
            {
                draw_text((128 - image_p->x) / 2, (128 - image_p->y) / 2, image_p);
            }
            state.text_visible++;
            if (state.text_visible > 32) state.text_visible = 0;



        }



    }
    return 0; // this is "good programming manners". Program informs it ended without errors
}

void get_buttons( button_type * state )
{

    state->timestamp =   mygame.getTime( );

    state->button_up_1 = state->button_up ;
    state->button_down_1 = state->button_down ;
    state->button_left_1 = state->button_left ;
    state->button_right_1 = state->button_right ;

    state->button_up = !mygame.buttons.upBtn() ;
    state->button_down = !mygame.buttons.downBtn() ;
    state->button_left = !mygame.buttons.leftBtn() ;
    state->button_right = !mygame.buttons.rightBtn() ;
}

void state_init(state_type* state)
{
    state->isGapRotating = 0;
    state->gapRotatingTimer = 1200;
    state->rotatingLevel = 0;

    state->game_state = GAME_GET_READY;
    state->text_visible = 0;

    state->levels[0] = 12;
    state->levels[1] = 32;
    state->levels[2] = 52;

    state->speeds[2] = DEG1;
    state->speeds[1] = DEG1 * 2;
    state->speeds[0] = DEG1 * 4;

#ifdef POK_SIM
    state->gaps[0] = { 12, 22,-DEG15, DEG45 };
    state->gaps[1] = { 32, 42,DEG60 - DEG6, DEG90 };
    state->gaps[2] = { 32, 42,DEG180 + DEG60 - DEG6, DEG180 + DEG90 };
    state->gaps[3] = { 52, 63,0, DEG30 };
    state->gaps[4] = { 52, 63,DEG180, DEG180 + DEG30 };
#else
    state->gaps[0] = ( gap_type)  {     12, 22, -DEG15, DEG45    };
    state->gaps[1] = ( gap_type)  {     32, 42, DEG60 - DEG6, DEG90  };
    state->gaps[2] = ( gap_type)  {     32, 42, DEG180 + DEG60 - DEG6, DEG180 + DEG90  };
    state->gaps[3] = ( gap_type)  {     52, 63, 0, DEG30  };
    state->gaps[4] = ( gap_type)  {     52, 63, DEG180, DEG180 + DEG30   };
#endif

    state->pacman.level = 2;
    state->pacman.r = state->levels[state->pacman.level];
    state->pacman.a = 0;
    state->pacman.anim = 0;
    state->pacman.anim_dir = DEG1;
    state->pacman.dir = DEG1;
    state->pacman.target_r = state->pacman.r;
    state->pacman.state = SPRITE_STANDBY;
    state->pacman.lock = 0;

    state->ghost[0].a = 0;
    state->ghost[0].r = state->levels[0];
    state->ghost[0].move = DEG1;
    state->ghost[0].state = SPRITE_ISCIRCULAR_MOVING;
    state->ghost[0].lock = 20;
    state->ghost[0].level_lock = 0;
    state->ghost[0].level = 0;
    state->ghost[1].a = DEG90;
    state->ghost[1].r = state->levels[0];
    state->ghost[1].move = DEG1;
    state->ghost[1].state = SPRITE_ISCIRCULAR_MOVING;
    state->ghost[1].lock = 20;
    state->ghost[1].level_lock = 0;
    state->ghost[1].level = 0;
    state->ghost[2].a = DEG180;
    state->ghost[2].r = state->levels[0];
    state->ghost[2].move = DEG1;
    state->ghost[2].state = SPRITE_ISCIRCULAR_MOVING;
    state->ghost[2].lock = 20;
    state->ghost[2].level_lock = 0;
    state->ghost[2].level = 0;
    state->ghost[3].a = DEG180 + DEG90;
    state->ghost[3].r = state->levels[0];
    state->ghost[3].move = DEG1;
    state->ghost[3].state = SPRITE_ISCIRCULAR_MOVING;
    state->ghost[3].lock = 20;
    state->ghost[3].level_lock = 0;
    state->ghost[3].level = 0;

    state->ghost[0].color = 3;
    state->ghost[1].color = 9;
    state->ghost[2].color = 10;
    state->ghost[3].color = 11;

    for (int8_t i = 0; i != 42; i++)
    {
        state->points[i].isEaten = false;
        state->points[i].isHidden = false;
    }

    int16_t point = 0;
    for (fix16_t a = 0; a <= DEG360; a = fix16_add(a, DEG15))
    {
        state->points[point].x = fix16_to_int(fix16_mul(fix16_from_int(52), fix16_cos(a))) + 64;
        state->points[point].y = fix16_to_int(fix16_mul(fix16_from_int(52), fix16_sin(a))) + 64;
        state->points[point].r = 52;
        state->points[point].a = a;
        point++;
    }
    for (fix16_t a = 0; a <= DEG360; a = fix16_add(a, DEG30))
    {
        state->points[point].x = fix16_to_int(fix16_mul(fix16_from_int(32), fix16_cos(a))) + 64;
        state->points[point].y = fix16_to_int(fix16_mul(fix16_from_int(32), fix16_sin(a))) + 64;
        state->points[point].r = 32;
        state->points[point].a = a;
        point++;
    }
    for (fix16_t a = 0; a <= DEG360; a = fix16_add(a, DEG60))
    {
        state->points[point].x = fix16_to_int(fix16_mul(fix16_from_int(12), fix16_cos(a))) + 64;
        state->points[point].y = fix16_to_int(fix16_mul(fix16_from_int(12), fix16_sin(a))) + 64;
        state->points[point].r = 12;
        state->points[point].a = a;
        point++;
    }
    state->points_count = point - 1;
}

bool checkGap(state_type* state, int16_t dir)
{
    int16_t level = state->pacman.level;
    bool result = false;
    if (dir == LEVEL_DOWN)
    {
        level = state->pacman.level - 1;
    }
    if (level >= 0)
    {
        for (int16_t i = 0; i != 5; i++)
        {
            if (state->gaps[i].r == state->levels[level] && state->gaps[i].start < fix16_sub(state->pacman.a, DEG12) && state->gaps[i].end > fix16_add(state->pacman.a, DEG12))
            {
                result = true;
            }
        }
    }
    return result;
}

bool checkGapGhost(state_type* state, int8_t index, int16_t dir)
{
    int16_t level = state->ghost[index].level;
    bool result = false;
    if (dir == LEVEL_DOWN)
    {
        level = state->ghost[index].level - 1;
    }
    if (level >= 0)
    {
//        if (level > 2 || level <0) break_cmd();
        for (int16_t i = 0; i != 5; i++)
        {
            if (state->gaps[i].r == state->levels[level] && state->gaps[i].start < fix16_sub(state->ghost[index].a, DEG12) && state->gaps[i].end > fix16_add(state->ghost[index].a, DEG12))
            {
                result = true;
                //cout << " s: " << fix16_to_float(state->gaps[i].start) << " e: " << fix16_to_float(state->gaps[i].end) << " g: " << fix16_to_float(state->ghost[index].a) << " i: " << (int16_t)index << " L: " << level << "\n";
            }
        }
    }
    return result;
}

void calc_state(state_type* state, button_type* buttons)
{

    // CIRCULAR MOVEMENT
    if (!buttons->button_left && state->pacman.state == SPRITE_STANDBY)
    {
        state->pacman.dir = -state->speeds[state->pacman.level];  //DEG_1;
        state->pacman.lock = 15;
        state->pacman.state = SPRITE_ISCIRCULAR_MOVING;
    }
    if (!buttons->button_right && state->pacman.state == SPRITE_STANDBY)
    {
        state->pacman.dir = state->speeds[state->pacman.level];  //DEG1;
        state->pacman.lock = 15;
        state->pacman.state = SPRITE_ISCIRCULAR_MOVING;
    }

    if (state->pacman.state == SPRITE_ISCIRCULAR_MOVING)
    {
        //if (state->pacman.lock > 0) state->pacman.lock--;
        //if (state->pacman.lock == 0)
        state->pacman.state = SPRITE_STANDBY;
        state->pacman.a = fix16_add(state->pacman.a, state->pacman.dir);
    }

    if (state->pacman.a > DEG360) state->pacman.a = fix16_sub(state->pacman.a, DEG360);
    if (state->pacman.a < 0) state->pacman.a = fix16_add(state->pacman.a, DEG360);

    // LEVEL CHANGE
    if (!buttons->button_up && state->pacman.state == SPRITE_STANDBY && checkGap(state, LEVEL_UP))
    {
        state->pacman.level++;
        if (state->pacman.level > 2)
        {
            state->pacman.level = 2;
            state->pacman.a = fix16_add(state->pacman.a, DEG180);
            state->pacman.lock = 30;
        }
        state->pacman.target_r = state->levels[state->pacman.level];
        state->pacman.state = SPRITE_ISMOVING;
    }

    if (!buttons->button_down && state->pacman.state == SPRITE_STANDBY && checkGap(state, LEVEL_DOWN))
    {
        state->pacman.level--;
        if (state->pacman.level < 0)
        {
            state->pacman.level = 0;
        }
        state->pacman.target_r = state->levels[state->pacman.level];
        state->pacman.state = SPRITE_ISMOVING;
    }

    if (state->pacman.state == SPRITE_ISMOVING)
    {
        if (state->pacman.lock > 0) state->pacman.lock--;
        if (state->pacman.target_r < state->pacman.r)  state->pacman.r--;
        if (state->pacman.target_r > state->pacman.r) state->pacman.r++;
        if (state->pacman.target_r == state->pacman.r && state->pacman.lock == 0)
        {
            state->pacman.state = SPRITE_STANDBY;
        }
    }

    // GHOST MOVING
    for (int8_t i = 0; i != 4; i++)
    {
        if (state->ghost[i].level_lock > 0) state->ghost[i].level_lock--;

        if (state->ghost[i].state == SPRITE_ISCIRCULAR_MOVING)
        {
            if (state->ghost[i].lock > 0) state->ghost[i].lock--;
            if (state->ghost[i].lock == 0)
            {
                state->ghost[i].lock = 120;
                if (state->ghost[i].r >= state->levels[1])
                {
                    state->ghost[i].move = (( mygame.getTime() >> i) & 1) ? DEG1 : DEG_1;
                }
            }
            state->ghost[i].a = fix16_add(state->ghost[i].a, state->ghost[i].move);
            if (state->ghost[i].a > DEG360) state->ghost[i].a = fix16_sub(state->ghost[i].a, DEG360);
            if (state->ghost[i].a < 0) state->ghost[i].a = fix16_add(state->ghost[i].a, DEG360);

            int16_t level = 0;
            bool go_up = checkGapGhost(state, i, LEVEL_UP);
            bool go_down = checkGapGhost(state, i, LEVEL_DOWN);
            if (state->ghost[i].level_lock == 0)
            {
                if (state->ghost[i].r == state->levels[1] && go_down)
                {
                    go_down = false;
                }

                level = go_up ? LEVEL_UP : go_down ? LEVEL_DOWN : 0;

                level = ((mygame.getTime() >> i) & 1) ? level : 0;
            }

            if (level)
            {
                if (level == LEVEL_DOWN)
                {
                    state->ghost[i].level--;
                    if (state->ghost[i].level < 0)
                    {
                        state->ghost[i].level = 0;
                    }
                    state->ghost[i].target_r = state->levels[state->ghost[i].level];
                    state->ghost[i].state = SPRITE_ISMOVING;
                }
                else
                {
                    state->ghost[i].level++;
                    if (state->ghost[i].level > 2)
                    {
                        state->ghost[i].level = 2;
                    }
                    state->ghost[i].target_r = state->levels[state->ghost[i].level];
                    state->ghost[i].state = SPRITE_ISMOVING;
                }
                state->ghost[i].level_lock = 120;
            }
        }
        if (state->ghost[i].state == SPRITE_ISMOVING)
        {
            if (state->ghost[i].target_r < state->ghost[i].r)  state->ghost[i].r--;
            if (state->ghost[i].target_r > state->ghost[i].r) state->ghost[i].r++;
            if (state->ghost[i].target_r == state->ghost[i].r)
            {
                state->ghost[i].state = SPRITE_ISCIRCULAR_MOVING;
            }
        }

        // GAP ROTATING
        state->gapRotatingTimer--;
        if (state->gapRotatingTimer == 0)
        {
            state->gapRotatingTimer = 1200;
            state->isGapRotating = 60;
            state->rotatingLevel = ((mygame.getTime() | buttons->timestamp) >> 1) & 0x03;
            if (state->rotatingLevel > 2) state->rotatingLevel = 0;
            // setOSC(&osc1,1,3,0,0,1,20 + 3*(2- state->rotatingLevel),246,15,91,101,54,0,0,0,0,1) ;
        }
        if (state->isGapRotating > 0)
        {
            state->isGapRotating--;
            for (int16_t i = 0; i != 5; i++)
            {
                if (state->gaps[i].r == state->levels[state->rotatingLevel])
                {
                    state->gaps[i].start = fix16_add(state->gaps[i].start, DEG1);
                    state->gaps[i].end = fix16_add(state->gaps[i].end, DEG1);

                    if (state->gaps[i].start > DEG360)
                    {
                        state->gaps[i].start = fix16_sub(state->gaps[i].start, DEG360);
                    }
                    if (state->gaps[i].end > DEG360)
                    {
                        state->gaps[i].end = fix16_sub(state->gaps[i].end, DEG360);
                    }
                    if (state->gaps[i].end < state->gaps[i].start)
                    {
                        state->gaps[i].end = fix16_add(state->gaps[i].end, DEG360);
                    }
                }
            }
        }

    }

    // PACMAN ANIM
    state->pacman.anim = fix16_add(state->pacman.anim, state->pacman.anim_dir);
    if (state->pacman.anim > DEG15) state->pacman.anim_dir = DEG_1;
    if (state->pacman.anim < DEG_3) state->pacman.anim_dir = DEG1;


    // HIDE or EAT POINTS

    for (int8_t i = 0; i != 42; i++)
    {
        state->points[i].isHidden = false;
        if (!state->points[i].isEaten && state->pacman.r == state->points[i].r &&  state->points[i].a > fix16_sub(state->pacman.a, DEG6) && state->points[i].a < fix16_add(state->pacman.a, DEG6))
        {
            state->points[i].isEaten = true;
            state->points_count--;

            // setOSC(&osc2,1,1,0,0,1,47,215,249,221,1,8,3,13,0,0,1) ;
        }
        for (int8_t g = 0; g != 4; g++)
        {
            if (state->ghost[g].r == state->points[i].r &&  state->points[i].a > fix16_sub(state->ghost[g].a, DEG12) && state->points[i].a < fix16_add(state->ghost[g].a, DEG12))
            {
                state->points[i].isHidden = true;
            }
        }
    }

    // COLLiSION
    bool collision = false;
    for (int8_t g = 0; g != 4; g++)
    {
        if (state->ghost[g].r == state->pacman.r &&  state->pacman.a > fix16_sub(state->ghost[g].a, DEG15) && state->pacman.a < fix16_add(state->ghost[g].a, DEG15))
        {
            collision = true;
            //std::cout << collision;
        }
    }
    if (collision)
    {
        state->game_state = GAME_GAME_OVER;
        setOSC(&osc1,1,2,0,1,1,25,246,28,14,173,6,-157,-257,0,0,0) ;
    }

    // check win
    if (state->points_count == 0)
    {
        state->game_state = GAME_YOU_WIN;
    }
}

void draw_pacman( state_type* s)
{
    fix16_t pac_anim = 0, pac_anim_dir = DEG1;
    coord start_coord, end_coord;

    int16_t current_level = 0;
    fix16_t start_angle = 0;
    for (int8_t i = 0; i != 5; i++)
    {
        if (current_level != s->gaps[i].r)
        {
            current_level = s->gaps[i].r;
            start_angle = s->gaps[i].start;
        }
        fix16_t start = s->gaps[i].end;
        fix16_t end = s->gaps[i].r == s->gaps[i + 1].r ? s->gaps[i + 1].start : fix16_add(start_angle, DEG360);
        arc(64, 64, s->gaps[i].draw_r, start, end, 1, &start_coord, &end_coord);
    }

    for (int8_t i = 0; i != 42; i++)
    {
        if (!s->points[i].isHidden && !s->points[i].isEaten)
        {
            //image[WIDTH * s->points[i].y + s->points[i].x] = 4;
            mygame.display.drawPixel( OFFSET_X + s->points[i].x, OFFSET_Y + s->points[i].y,4 );
        }
    }

    int16_t pac_x = fix16_to_int(fix16_mul(fix16_from_int(s->pacman.r), fix16_cos(s->pacman.a))) + 64;
    int16_t pac_y = fix16_to_int(fix16_mul(fix16_from_int(s->pacman.r), fix16_sin(s->pacman.a))) + 64;

    arc(pac_x,
        pac_y,
        8,
        fix16_add(fix16_add(s->pacman.a, s->pacman.dir > 0 ? DEG105 : DEG105 + DEG180), s->pacman.anim),
        fix16_sub(fix16_add(s->pacman.a, s->pacman.dir > 0 ? DEG435 : DEG435 + DEG180), s->pacman.anim),

        8,
        &start_coord,
        &end_coord);
    drawline(pac_x, pac_y, start_coord.x, start_coord.y,  8);
    drawline(pac_x, pac_y, end_coord.x, end_coord.y, 8);

    for (int8_t i = 0; i != 4; i++)
    {
        int16_t g_x = fix16_to_int(fix16_mul(fix16_from_int(s->ghost[i].r - 2), fix16_cos(s->ghost[i].a))) + 64;
        int16_t g_y = fix16_to_int(fix16_mul(fix16_from_int(s->ghost[i].r - 2), fix16_sin(s->ghost[i].a))) + 64;
        ghost(g_x, g_y, s->ghost[i].a,  s->ghost[i].color);
    }
}

void circle(uint16_t x0, uint16_t y0, uint16_t r,uint8_t color)
{
    fix16_t step = DEG1;
    for (fix16_t a = 0; a < DEG360; a = fix16_add(a, step))
    {
        int16_t x = fix16_to_int(fix16_mul(fix16_from_int(r), fix16_cos(a)));
        int16_t y = fix16_to_int(fix16_mul(fix16_from_int(r), fix16_sin(a)));

        //fb[WIDTH * (y + y0) + x + x0] = color;
        mygame.display.drawPixel( OFFSET_X + x+x0, OFFSET_Y + y+y0,color );
    }
}

void ghost(uint16_t x0, uint16_t y0, fix16_t angle, uint8_t color)
{
    coord start, end;

    angle = fix16_add(angle, DEG90);

    fix16_t points_r[12] = { 262140,419629,	463402,	419629,	463402,	185361,	327675,	236290,	236290,	185361,293081,	293081 };
    fix16_t points_a[12] = { -102942,-161665,154413,-44219,51471,	154413,	102942,	167350,	38535,	51471,-72557,	-133327 };

    int16_t points_x[12], points_y[12];

    for (uint16_t i = 0; i != 12; i++)
    {
        points_x[i] = fix16_to_int(fix16_mul(points_r[i], fix16_cos(fix16_add(angle, points_a[i])))) + x0;
        points_y[i] = fix16_to_int(fix16_mul(points_r[i], fix16_sin(fix16_add(angle, points_a[i])))) + y0;
    }

    arc(points_x[0],
        points_y[0],
        5,
        fix16_add(angle, DEG180),
        fix16_add(angle, DEG360),

        color,
        &start,
        &end);
    drawline(points_x[1], points_y[1], points_x[2], points_y[2],  color);
    drawline(points_x[3], points_y[3], points_x[4], points_y[4],  color);

    drawline(points_x[2], points_y[2], points_x[5], points_y[5],  color);
    drawline(points_x[6], points_y[6], points_x[7], points_y[7],  color);
    drawline(points_x[6], points_y[6], points_x[8], points_y[8],  color);
    drawline(points_x[4], points_y[4], points_x[9], points_y[9],  color);

//	image[WIDTH * points_y[10] + points_x[10]] = color;
//	image[WIDTH * points_y[11] + points_x[11]] = color;
    mygame.display.drawPixel( OFFSET_X + points_x[10], OFFSET_Y +points_y[10],color );
    mygame.display.drawPixel( OFFSET_X + points_x[11], OFFSET_Y + points_y[11],color);
}

void arc(uint16_t x0, uint16_t y0, uint16_t r, fix16_t start, fix16_t end, uint8_t color, coord * result_start, coord *result_end)
{
    fix16_t step = DEG12;
    fix16_t r_fix = fix16_from_int(r);

    result_start->x = fix16_to_int(fix16_mul(r_fix, fix16_cos(start))) + x0;
    result_start->y = fix16_to_int(fix16_mul(r_fix, fix16_sin(start))) + y0;
    result_end->x = fix16_to_int(fix16_mul(r_fix, fix16_cos(end))) + x0;
    result_end->y = fix16_to_int(fix16_mul(r_fix, fix16_sin(end))) + y0;

    int16_t x_1 = result_start->x;
    int16_t y_1 = result_start->y;

    for (fix16_t a = start; a < end; a = fix16_add(a, step))
    {
        int16_t x = fix16_to_int(fix16_mul(r_fix, fix16_cos(a))) + x0;
        int16_t y = fix16_to_int(fix16_mul(r_fix, fix16_sin(a))) + y0;

        drawline(x_1, y_1, x, y,  color);
        x_1 = x;
        y_1 = y;
    }
    drawline(x_1, y_1, result_end->x, result_end->y,  color);
}

void filled_arc(uint16_t x0, uint16_t y0, uint16_t r, fix16_t start, fix16_t end,  uint8_t color)
{
    fix16_t step = DEG3;
    fix16_t r_fix = fix16_from_int(r);
    for (fix16_t a = start; a < end; a = fix16_add(a, step))
    {
        int16_t x = fix16_to_int(fix16_mul(r_fix, fix16_cos(a))) + x0;
        int16_t y = fix16_to_int(fix16_mul(r_fix, fix16_sin(a))) + y0;

        drawline(x0, y0, x, y,  color);
    }
}

void drawline(int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint8_t color)
{
    int16_t dx, dy, p, x, y;
    x = x1;
    y = y1;
    dx = abs(x2 - x1);
    dy = abs(y2 - y1);

    int16_t s1 = sign(x2 - x1);
    int16_t s2 = sign(y2 - y1);
    int16_t swap = 0;

    if (dy > dx)
    {
        int16_t temp = dx;
        dx = dy;
        dy = temp;
        swap = 1;
    }
    int16_t D = 2 * dy - dx;

    for (int16_t i = 0; i < dx; i++)
    {
//		fb[WIDTH * y + x] = color;
        mygame.display.drawPixel( OFFSET_X +  x,OFFSET_Y +y,color );
        while (D >= 0)
        {
            D = D - 2 * dx;
            if (swap) x += s1;
            else y += s2;
        }
        D = D + 2 * dy;
        if (swap) y += s2;
        else x += s1;
    }
}

void draw_text(uint8_t x0, uint8_t y0, const bitmap_type* bitmap)
{
    for (int16_t y = 0; y != bitmap->y; y++)
    {
        for (int16_t x = 0; x != bitmap->x; x++)
        {
            uint8_t pix = bitmap->data[y*bitmap->x + x];
            if (pix != 0xff)
            {
                //image[(y0 + y)*WIDTH + x0 + x] = pix;
                mygame.display.drawPixel(OFFSET_X + x0+x,OFFSET_Y +y0+y,pix) ;
            }
        }
    }
}
